🔹 What Is Polymorphism (The Brutal Truth)

Polymorphism = "many forms."

In programming terms:

The same method name or action can behave differently based on the object type or context.

It’s the core of OOP flexibility — letting you write code that’s generic, reusable, and extensible.

🔹 2 Types of Polymorphism in Java
Type	When Decided	Mechanism	Example
Compile-time (Static)	At compile time	Method overloading	add(int a, int b) vs add(double a, double b)
Runtime (Dynamic)	At runtime	Method overriding	Parent p = new Child(); p.show();

⚙️ 1. Compile-Time Polymorphism (Static Binding)

This happens inside the compiler.
You have multiple methods with the same name, but different parameters (number or type).

This is method overloading.

Example:
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(2, 3));        // calls int version
        System.out.println(c.add(2.5, 3.5));    // calls double version
        System.out.println(c.add(1, 2, 3));     // calls 3-arg version
    }
}


Output:

5
6.0
6


✅ The compiler decides which version to call based on method signature (parameter count + types).
That’s why it’s static polymorphism — no runtime decision-making.

⚠️ Limitations:

It’s not real polymorphism — no dynamic dispatch.

Everything is fixed before execution.

You can’t overload just by return type (ambiguous).

⚙️ 2. Runtime Polymorphism (Dynamic Binding)

This is the real polymorphism that makes OOP powerful.
It happens via inheritance + method overriding.

The method that gets executed is determined at runtime based on the object’s actual type, not the reference type.

Example:
class Animal {
    void sound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.sound();   // Dog’s version
        a2.sound();   // Cat’s version
    }
}


Output:

Dog barks
Cat meows

🔍 What’s Actually Happening Under the Hood

When you call a1.sound():

The compiler sees the reference type Animal → checks that sound() exists. ✅

The object in memory is actually a Dog.

At runtime, the JVM looks up the Dog class’s version of sound() using a vtable (virtual method table).

The overridden version executes.

So:

Compile-time check: method exists ✅

Runtime check: which version to execute 🔍

That’s dynamic binding.

🔹 Why We Need This (Practical Power)

Imagine building a game:

class Enemy { void attack() { System.out.println("Enemy attacks"); } }
class Zombie extends Enemy { void attack() { System.out.println("Zombie bites"); } }
class Vampire extends Enemy { void attack() { System.out.println("Vampire sucks blood"); } }


Now you can do:

Enemy[] enemies = { new Zombie(), new Vampire() };

for (Enemy e : enemies)
    e.attack();  // Each behaves differently


Output:

Zombie bites
Vampire sucks blood


Your code is now open for extension, closed for modification.
You can add a new class Werewolf without touching this loop — the polymorphic behavior “just works.”

That’s the entire point of polymorphism.

🔹 Using super in Polymorphism

If you want the child to extend the parent’s behavior, not completely replace it:

class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound();  // call parent first
        System.out.println("Dog barks");
    }
}


Output:

Animal sound
Dog barks

🔹 Another Real-World Example: Payment System
abstract class Payment {
    abstract void process();
}

class CreditCardPayment extends Payment {
    void process() {
        System.out.println("Processing Credit Card Payment");
    }
}

class UpiPayment extends Payment {
    void process() {
        System.out.println("Processing UPI Payment");
    }
}

public class Main {
    public static void main(String[] args) {
        Payment p;

        p = new CreditCardPayment();
        p.process();

        p = new UpiPayment();
        p.process();
    }
}


Output:

Processing Credit Card Payment
Processing UPI Payment


No need for if-else or switch logic.
Just create the right subclass — the correct logic executes automatically.

That’s clean polymorphic design.


    🔹 How the JVM Decides (Internally)

    Here’s what happens step-by-step during runtime polymorphism:

    Object created: new Child() → heap memory stores full object (including parent part).

    Reference stored: Parent p = new Child();

    Method call: p.show() triggers:

    Compiler checks if show() exists in Parent (✅)

    JVM looks up Child’s version of show() (via vtable)

    Executes that method dynamically.



    🔹 Common Misconceptions (That Trip Up Beginners)

    ❌ “Polymorphism means you can access child methods from parent reference.”
    ➡️ Wrong. Only overridden methods are polymorphic; new methods need downcasting.

    ❌ “Overloading is true polymorphism.”
    ➡️ Not really — it’s a compile-time trick, not real dynamic behavior.

    ❌ “The parent reference doesn’t know about the child.”
    ➡️ It knows only the interface (methods declared in the parent), not the specific implementation until runtime.