ğŸ”¹ What Is Polymorphism (The Brutal Truth)

Polymorphism = "many forms."

In programming terms:

The same method name or action can behave differently based on the object type or context.

Itâ€™s the core of OOP flexibility â€” letting you write code thatâ€™s generic, reusable, and extensible.

ğŸ”¹ 2 Types of Polymorphism in Java
Type	When Decided	Mechanism	Example
Compile-time (Static)	At compile time	Method overloading	add(int a, int b) vs add(double a, double b)
Runtime (Dynamic)	At runtime	Method overriding	Parent p = new Child(); p.show();

âš™ï¸ 1. Compile-Time Polymorphism (Static Binding)

This happens inside the compiler.
You have multiple methods with the same name, but different parameters (number or type).

This is method overloading.

Example:
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(2, 3));        // calls int version
        System.out.println(c.add(2.5, 3.5));    // calls double version
        System.out.println(c.add(1, 2, 3));     // calls 3-arg version
    }
}


Output:

5
6.0
6


âœ… The compiler decides which version to call based on method signature (parameter count + types).
Thatâ€™s why itâ€™s static polymorphism â€” no runtime decision-making.

âš ï¸ Limitations:

Itâ€™s not real polymorphism â€” no dynamic dispatch.

Everything is fixed before execution.

You canâ€™t overload just by return type (ambiguous).

âš™ï¸ 2. Runtime Polymorphism (Dynamic Binding)

This is the real polymorphism that makes OOP powerful.
It happens via inheritance + method overriding.

The method that gets executed is determined at runtime based on the objectâ€™s actual type, not the reference type.

Example:
class Animal {
    void sound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.sound();   // Dogâ€™s version
        a2.sound();   // Catâ€™s version
    }
}


Output:

Dog barks
Cat meows

ğŸ” Whatâ€™s Actually Happening Under the Hood

When you call a1.sound():

The compiler sees the reference type Animal â†’ checks that sound() exists. âœ…

The object in memory is actually a Dog.

At runtime, the JVM looks up the Dog classâ€™s version of sound() using a vtable (virtual method table).

The overridden version executes.

So:

Compile-time check: method exists âœ…

Runtime check: which version to execute ğŸ”

Thatâ€™s dynamic binding.

ğŸ”¹ Why We Need This (Practical Power)

Imagine building a game:

class Enemy { void attack() { System.out.println("Enemy attacks"); } }
class Zombie extends Enemy { void attack() { System.out.println("Zombie bites"); } }
class Vampire extends Enemy { void attack() { System.out.println("Vampire sucks blood"); } }


Now you can do:

Enemy[] enemies = { new Zombie(), new Vampire() };

for (Enemy e : enemies)
    e.attack();  // Each behaves differently


Output:

Zombie bites
Vampire sucks blood


Your code is now open for extension, closed for modification.
You can add a new class Werewolf without touching this loop â€” the polymorphic behavior â€œjust works.â€

Thatâ€™s the entire point of polymorphism.

ğŸ”¹ Using super in Polymorphism

If you want the child to extend the parentâ€™s behavior, not completely replace it:

class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound();  // call parent first
        System.out.println("Dog barks");
    }
}


Output:

Animal sound
Dog barks

ğŸ”¹ Another Real-World Example: Payment System
abstract class Payment {
    abstract void process();
}

class CreditCardPayment extends Payment {
    void process() {
        System.out.println("Processing Credit Card Payment");
    }
}

class UpiPayment extends Payment {
    void process() {
        System.out.println("Processing UPI Payment");
    }
}

public class Main {
    public static void main(String[] args) {
        Payment p;

        p = new CreditCardPayment();
        p.process();

        p = new UpiPayment();
        p.process();
    }
}


Output:

Processing Credit Card Payment
Processing UPI Payment


No need for if-else or switch logic.
Just create the right subclass â€” the correct logic executes automatically.

Thatâ€™s clean polymorphic design.


    ğŸ”¹ How the JVM Decides (Internally)

    Hereâ€™s what happens step-by-step during runtime polymorphism:

    Object created: new Child() â†’ heap memory stores full object (including parent part).

    Reference stored: Parent p = new Child();

    Method call: p.show() triggers:

    Compiler checks if show() exists in Parent (âœ…)

    JVM looks up Childâ€™s version of show() (via vtable)

    Executes that method dynamically.



    ğŸ”¹ Common Misconceptions (That Trip Up Beginners)

    âŒ â€œPolymorphism means you can access child methods from parent reference.â€
    â¡ï¸ Wrong. Only overridden methods are polymorphic; new methods need downcasting.

    âŒ â€œOverloading is true polymorphism.â€
    â¡ï¸ Not really â€” itâ€™s a compile-time trick, not real dynamic behavior.

    âŒ â€œThe parent reference doesnâ€™t know about the child.â€
    â¡ï¸ It knows only the interface (methods declared in the parent), not the specific implementation until runtime.